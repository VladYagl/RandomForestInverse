\chapter{Предложенные алгоритмы оптимизации случайного леса}\label{chap:second}

\section{Метод имитации отжига}\label{sec:odod}

Перед началом алгоритма все пространство разбивается на прямоугольную сетку, где
каждая прямая соответствует одному из порогов разветвлений в вершине одного из
деревьев. Для всех прямых также храниться информация в каком дереве происходит
разветвление по данной границе. Тем самым мы сводим задачу из вещественной
оптимизации к дискретному случаю, к чему более применим алгоритм имитации
отжига. Важно заметить, что по одному и тому же разбиению могут происходить
несколько вершин в разный деревьях или в одном дереве.

В процессе имитации отжига выполняются случайные мутации по переходу в соседнюю
клетку сетки. Так как при таком переходе пересекается лишь одна граница, для
получения нового значения достаточно пересчитать лишь те деревья в которых есть
эта граница, то есть те, что был и сохранены ранее для границ.

От температурного параметра зависит вероятность перехода в клетку не улучшающею
ответ найденный в текущей точке, формулы для расчёта вероятности описаны
в секции~\ref{sec:od}.

\subsection{Теоретическое сравнение}

\begin{itemize}
    \item \textbf{Преимущество метода:} Константное время работы, не
    зависящие от внутренней сложности устройства конкретных деревьев в лесе.
    В случае обновления леса новой информацией можно начинать поиск из точки
    минимума/максимума найденной ранее.
    \item \textbf{Недостатки метода:} Так как это общий метод оптимизации функции, то
    данный метод не использует внутреннею структуру случайного леса,
    а рассматривает его как 'чёрный ящик'. Кроме этого, часто переход в соседнюю
    клетку происходит по границе, которая не влияет на текущее значение,
    следовательно оно не изменяется. В итоге алгоритму приходится делать большое
    количество не существенных мутаций, что усложняет его работу.
\end{itemize}

\subsection{Результаты}

В результате экспериментов (Подробнее об это в секции~\ref{sec:error}) данный
метод не продемонстрировал желаемых результатов, и было принято решение
отказаться от него в пользу более эффективных. Возможно существуют более
эффективные реализации метода имитации отжига в применении к поставленной
задаче, не рассмотренные в данной работе. Возможное улучшение может быть, если
вместо того, чтобы на каждом шаге рассматривать все пороги всех вершин, можно
рассматривать только вершины на пути от текущей точки до корня дерева принятия
решений.

\section{Метод ветвей и границ}\label{sec:heu}

В алгоритме применяется полный перебор всех поддеревьев. В процессе перебора
поддерживается следующий инвариант: все рассматриваемые поддеревья имеют не
пустое пересечение. Тем самым в каждый момент времени рассматривается некоторая
область в виде n-мерного прямоугольника. На каждом шаге перебора, то есть
переходе из вершины в левого или правого ребёнка, эта область разрезается на две
части по границе из вершины, в которой был совершён шаг.

Тем самым для применения метода ветвей и границ необходимо оценить возможные
занижения возвращаемые лесом в рассматриваемом в конкретный момент времени
прямоугольнике. Для оценки максимума и минимума функции в этой области для
каждой вершины посчитано максимальное значение в её поддереве. Так как случайный
лес возвращает среднее значение всех деревьев, то в данной области лес не может
вернуть значение больше (меньше) чем среднее по всем достижимым максимумам
(минимумам) в поддеревьях, задающих эту область. Что позволяет нам получить
необходимые ограничения на оптимизируемую функцию.

В итоге на каждом шаге метода \emph{ветвей и границ} алгоритм сначала производит
\emph{ветвление} (усечение рассматриваемой области, путём спуска вниз на один
уровень в одном из деревьев принятия решения), после чего оценивает
\emph{границы} в текущей области, описанным раннее способом. Тем самым,
эффективность алгоритма зависит от выбора в каком из поддеревьев сначала
совершать обход, потому что, если алгоритм быстро найдёт верное, или же
достаточно близкое значение, то тогда он сможет пропустить большое количество
гарантированно неэффективных поддеревьев.

Далее описана эвристика в процессе выбора следующего поддерева, которая как,
в последствии будет повреждено экспериментально, значительно ускоряет процесс
обхода случайного леса.

\subsection{Эвристика}

Основная эвристическая оптимизация --- перебирать сначала те поддеревья,
в которых разница между оценёнными значениями левого и правого поддерева
максимальна.

\[
    i = \arg \max_{v \in trees}(|value[v.left] - value[v.right]|)
\]

Идея основывается на предположении, что после обхода поддерева первого ребёнка
в такой паре. Из-за максимальной разницы между ними следует большая вероятность
того, что алгоритму не придётся рассматривать поддерево второго ребёнка, так как
в первом поддереве было найдено лучшее значение.

\subsection{Нахождение приближенного значения}

Для поиска ответа с заданной точностью применена следующая оптимизация. Алгоритм
не рассматривает те поддеревья которые гарантированно не превосходят ранее
найденный ответ на больше чем заданное $\alpha$.

\[
    value[v] < \alpha current
\]

Это позволяет находить ответ отличающийся от истинного не более чем на заданную
точность, потому что если найденный ответ отличается больше, то не было
рассмотрено его поддерево, что невозможно так как возможный максимум в нем
больше.

Отметим, что с линейным увеличением допустимой погрешности $\alpha$ алгоритм
раньше (на меньшей глубине дерева) прекратит обход неэффективного поддерева.
А так как количество вершин в поддереве растёт экспоненциально в зависимости от
его глубины, то таким образом с линейным ростом погрешности экспоненциально
растёт количество пропущенных вершин, а следовательно уменьшается время работы.
Это будет подтверждено экспериментально далее в работе.

\subsection{Уточнение границ в поддереве}

Заметим, что максимум в поддереве может не пересекаться с областью, которую
рассматривает алгоритм в конкретный момент. Из-за этого алгоритм может
перебирать поддеревья, максимум в которых заведомо не достижим.

Чтобы это исправить для каждого дерева принятия решений посчитан отсортированный
список всех его листьев. Данный список строиться путём последовательного слияния
списков детей в каждой вершине, что асимптотически добавляет $O(N \log{N})$
времени к предподсчету алгоритма, где $N$ --- количество листьев в дереве.

Так как на каждом шаге алгоритма новая полученная область строго включается
в старую, в таком отсортированном списке возможный максимум в поддереве строго
движется вперёд. В итоге за добавление линейного времени на каждый спуск
возможно оценить максимум в поддереве, пересекающийся с текущей рассматриваемой
областью.

Следует заметить, что данную оптимизацию следует применять лишь в случае, когда
в исходном наборе данных количество признаков не слишком велико (примерно
$<20$\footnote{эмпирически полученное значение в результате серии
экспериментов}), так как на каждом шаге приходиться вычислять пересечение
текущей рассматриваемой области, с областями соответствующими листьям деревьев.
А данное пересечение выполняется за $O(m)$, где $m$ --- количество признаков
в данных. Также улучшение заметно лишь при большем количестве деревьев
в случайном лесу.

\subsection{Оптимизация в заданной области}

Отметим, что в данной реализации алгоритма, можно задать начальные ограничения
на пространство признаков, в котором происходит поиск максимума или минимума.
Для этого достаточно задать начальную область алгоритма не все пространство,а
требуемую область. Так как алгоритм в своей работе поддерживает, что все
поддеревья пересекаются с текущей рассматриваемой областью, алгоритм
автоматически будет рассматривать, только поддеревья в заданной границе. Что
позволяет решать задачу оптимизации не на всем пространстве, а в конкретной
области.

\section{Практическое применение}\label{sec:smac}

Описанный выше алгоритм может быть приманен для улучшения существующих
алгоритмов. Поэтому, чтобы продемонстрировать применимость разработанного метода
на практике, в данном исследовании произведена успешная попытка улучшить
алгоритм подбора гиперпараметров SMAC, применением в нем поиска минимума
в случном лесе с помощь. предложенного алгоритма.

\subsection{Лес случайных деревьев в алгоритме SMAC}

В ходе своей работы SMAC использует лес случайных деревьев для предсказания
ожидаемого улучшения при использовании соответствующего набора гиперпараметров.

Алгоритм состоит из нескольких итераций. На каждой итерации, сначала
регрессионная модель (в данном случае случайны лес) обновляется новыми данными,
после чего собираются новые данные в точках выбранных на основе обновленной
модели.

\subsection{Модификация с применением разработанного алгоритма}

Были модифицированы \texttt{automl} реализации с открытым исходным кодом:
\texttt{random\_forest\_run} и \texttt{SMAC}. В \texttt{random\_forest\_run} был
добавлен эвристический алгоритм для поиска минимальной и максимальной области.
Последняя оптимизация не была реализована, так как она рассчитана на большое
количество деревьев. А в \texttt{automl} реализации SMAC используется случайный
лес с $10$ деревьями, и в таком случае данная оптимизация лишь замедляет работу
алгоритма.

В предложенной реализации алгоритма SMAC случайный выбор конфигураций
гиперпараметров заменён на поиск минимального значения в текущей регрессионной
можели (случайный лес). Алгоритм возвращает $\gamma * size$ различных
конфигураций из найденной максимальной области случайного леса, и оставшиеся $(1
- \gamma) * size$ выбираются случайно. Это делается потому, что текущий
регрессионной лес может не точно отражать, реальное поведение целевого
алгоритма. Тем самым алгоритм избегает переобучения регрессионной модели.
Параметр $\gamma$ может быть задан пользователем в аргументах оптимизатора,
исходя из конкретного применения предложенного алгоритма. В данной работе
применяется $\gamma=0.8$ выбранное эмпирически, как более эффективное
в большинстве случаев.

\chapterconclusion

В данной главе предложены два метода оптимизации случайного регрессионного леса
применённые в работе, и как эти методы применяются для решения задачи,
поставленной в работе. Изложены применённые оптимизации к этим методам и детали
реализации в конкретной работе.

Отметим, что если метод имитации отжига является идейным продолжении
применяющихся сейчас на практике решений поставленной задачи, то метод ветвей
и границ является кардинально новым подходом к решению оптимизации случайного
леса.

При экспериментальном исследовании, от метода имитации отжига было принято решение
отказаться в пользу метода ветвей и границ.

Также в данной главе описано практическое применения разработанного алгоритма
поиска минимума в случайном лесе. Предложена модификация алгоритма выбора
конфигураций гиперпараметров SMAC\@.
